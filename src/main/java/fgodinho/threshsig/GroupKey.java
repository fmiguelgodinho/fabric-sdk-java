package fgodinho.threshsig;

import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.spec.RSAPublicKeySpec;
import java.util.Base64;

/**
 * A GroupKey with information common to all the keyshares. Generated by the
 * Dealer class
 *
 * Reference: "Practical Threshold Signatures",<br>
 * Victor Shoup (sho@zurich.ibm.com), IBM Research Paper RZ3121, 4/30/99<BR>
 *
 * @author Steve Weis <sweis@mit.edu>
 */

// TODO: Investigate the security of reusing the key parameters (q,p) with a
// new Poly, since they are computationally expensive
public class GroupKey {

/** (k,l) Parameters. k out of l shares needed for a signature */
  private int k, l;

  /** The exponent of the groupKeyPair */
  private BigInteger e;

  /** The RSA modulus of the groupKeyPair */
  private BigInteger n;

  public GroupKey(final int k, final int l, final int keysize, final BigInteger v,
      final BigInteger e, final BigInteger n) {
    this.k = k;
    this.l = l;
    this.e = e;
    this.n = n;
  }

  /**
   * Returns the minimum threshold size
   *
   * @return The minimum threshold size for this group 'k'.
   */
  public int getK() {
    return k;
  }

  /**
   * Returns the group size
   *
   * @return The size of this key's associated group.
   */
  public int getL() {
    return l;
  }

  /**
   * Returns the group key modulus
   *
   * @return This group's modulus.
   */
  public BigInteger getModulus() {
    return n;
  }

  /**
   * Returns the group key exponent
   *
   * @return This group's exponent
   */
  public BigInteger getExponent() {
    return e;
  }

  // /FGODINHO

  public GroupKey(final int k, final int l, final BigInteger e, final BigInteger n) {
	    this.k = k;
	    this.l = l;
	    this.e = e;
	    this.n = n;
  }

  @Override
  public String toString() {

	byte[] expBytes = e.toByteArray();
	byte[] modBytes = n.toByteArray();

	byte[] groupKeyBytes = ByteBuffer
  		.allocate(4 + 4 + 4 + expBytes.length + 4 + modBytes.length) // 4 for k, 4 for l, 4 for size of exp, exp, 4 for size of mod, mod
  		.putInt(k)
  		.putInt(l)
  		.putInt(expBytes.length)
  		.put(expBytes)
  		.putInt(modBytes.length)
  		.put(modBytes)
  		.array();

	return Base64.getEncoder().encodeToString(groupKeyBytes);
  }

  public static GroupKey fromBytes(byte[] hexKey) {

	  byte[] groupKeyBytes = Base64.getDecoder().decode(hexKey);
	  return parseGroupKey(groupKeyBytes);
  }

  public static GroupKey fromString(String hexKey) {

	  byte[] groupKeyBytes = Base64.getDecoder().decode(hexKey);
	  return parseGroupKey(groupKeyBytes);
  }


  private static GroupKey parseGroupKey(byte[] groupKeyBytes) {

	  ByteBuffer bb = ByteBuffer.wrap(groupKeyBytes);

	  // get k and l
	  int k = bb.getInt();
	  int l = bb.getInt();

	  // get exp
	  int expBytesLen = bb.getInt();
	  byte[] expBytes = new byte[expBytesLen];
	  bb.get(expBytes, 0, expBytesLen);
	  BigInteger exp = new BigInteger(expBytes);

	  // get mod
	  int modBytesLen = bb.getInt();
	  byte[] modBytes = new byte[modBytesLen];
	  bb.get(modBytes, 0, modBytesLen);
	  BigInteger mod = new BigInteger(modBytes);

	  // return new key
	  return new GroupKey(k, l, exp, mod);
  }
}
